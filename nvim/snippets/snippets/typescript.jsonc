{
  "Import external module.": {
    "prefix": [
      "imc",
      "impc"
    ],
    "body": [
      "import { $2 } from '${1:module}';$3"
    ],
    "description": "Import external module."
  },
  "Import external module (without curly brackets)": {
    "prefix": [
      "im",
      "imp"
    ],
    "body": [
      "import ${2:*} from '${1:module}';$3"
    ],
    "description": "Import external module."
  },
  "Import * as _": {
    "prefix": [
      "im*",
      "imp*"
    ],
    "body": [
      "import * as $1 from '${2:module}';$3"
    ],
    "description": "이렇게 해야 lsp가 module 명을 알려주는듯?"
  },
  "Import type": {
    "prefix": [
      "imt",
      "impt"
    ],
    "body": [
      "import type {$2} from '${1:module}';$3"
    ],
    "description": "Import external module."
  },
  "for-entries": {
    "prefix": "foren",
    "body": [
      "for (const [key, val] of Object.entries(${object:1}) {",
      "\t$0",
      "}"
    ],
    "description": "객체의 키·값을 순회"
  },
  "Interface Definition": {
    "prefix": [
      "iface",
      "interface",
      "int"
    ],
    "body": [
      "interface ${1:name} {",
      "\t$0",
      "}"
    ],
    "description": "Interface Definition"
  },
  "const statement": {
    "prefix": "c",
    "body": "const ${1:name}"
  },
  "const statement from destructuring (fs)": {
    "prefix": "cd",
    "body": "const { ${2:prop} } = ${1:value}"
  },
  "const statement from array destructuring": {
    "prefix": "cad",
    "body": "const [ ${2:prop} ] = ${1:value}"
  },
  "const assignment awaited": {
    "prefix": "ca",
    "body": "const ${1:name} = await ${2:value}"
  },
  "const destructuring assignment awaited": {
    "prefix": "cda",
    "body": "const { ${1:name} } = await ${2:value}"
  },
  "const arrow function assignment": {
    "prefix": "cf",
    "body": "const ${1:name} = (${2:arguments}) => {\n\treturn ${0}\n}"
  },
  "Class Definition": {
    "prefix": [
      "cls",
      "class"
    ],
    "body": [
      "class ${1:name} {",
      "\t$0",
      "}"
    ],
    "description": "Class Definition"
  },
  "Method Definition": {
    "prefix": [
      "meth",
      "method"
    ],
    "body": [
      "${1:name}(${2:arguments})${3:return type} {",
      "\t$0",
      "}"
    ],
    "description": "Method Definition"
  },
  "Arrow Function": {
    "prefix": "af",
    "body": "(${1:arguments}) => $0"
  },
  "Arrow Function with return": {
    "prefix": "afr",
    "body": "(${1:arguments}) => {\n\treturn ${0}\n}"
  },
  "ASync Function": {
    "prefix": "asf",
    "body": "async function ${1:name}(${2:arguments}) {\n\t${0}\n}"
  },
  "Async Arrow Function": {
    "prefix": "asaf",
    "body": "async (${1:arguments}) => {\n\t${0}\n}"
  },
  "Async Method": {
    "prefix": "asm",
    "body": "async ${1:name}(${2:arguments}): Promise<${3:returnType}> {\n\t${0}\n}"
  },
  "export": {
    "prefix": [
      "ex",
      "exp",
      "expo",
      "expor",
      "export"
    ],
    "body": "export $0"
  },
  "console.log": {
    "prefix": "log",
    "body": "console.log($1);$0",
    "description": "Log to the console"
  },
  "console.warn": {
    "prefix": "warn",
    "body": [
      "console.warn($1);",
      "$0"
    ],
    "description": "Log warning to the console"
  },
  "console.error": {
    "prefix": "err",
    "body": [
      "console.error($1);",
      "$0"
    ],
    "description": "Log error to the console"
  },
  "switch": {
    "prefix": [
      "swi"
    ],
    "body": [
      "switch (${1:'expression'}) {",
      "\t$0",
      "\tdefault: {",
      "\t\t${2:'statement'};",
      "\t\tbreak;",
      "\t}",
      "}"
    ],
    "description": "switch"
  },
  "case": {
    "prefix": [
      "cas"
    ],
    "body": [
      "case ${1:'constant-expression'}: {",
      "\t$0",
      "\tbreak;",
      "}"
    ],
    "description": "case"
  },
  "If Statement": {
    "prefix": "if",
    "body": [
      "if (${1:condition}) {",
      "\t$0",
      "}"
    ],
    "description": "If Statement"
  },
  "If-Else Statement": {
    "prefix": "ifelse",
    "body": [
      "if (${1:condition}) {",
      "\t$0",
      "} else {",
      "\t",
      "}"
    ],
    "description": "If-Else Statement"
  },
  "Else Statement": {
    "prefix": "else",
    "body": [
      "else {",
      "\t",
      "}"
    ],
    "description": "(If-)Else Statement"
  },
  "Try-Catch Statement": {
    "prefix": "trycatch",
    "body": [
      "try {",
      "\t$0",
      "} catch (${1:error}) {",
      "\t",
      "}"
    ],
    "description": "Try-Catch Statement"
  },
  "Catch Statement": {
    "prefix": "catch",
    "body": [
      "catch (${1:error}) {",
      "\t$0",
      "}"
    ],
    "description": "Catch Statement"
  },
  "require": {
    "prefix": [
      "req"
    ],
    "body": "require($1)$0",
    "description": ""
  },
  "tsx-root": {
    "prefix": [
      "troot"
    ],
    "body": "const root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement)",
    "description": ""
  },
  "tsx-useCallback": {
    "prefix": [
      "usecallbac"
    ],
    "body": [
      "useCallback(($1) => {\n\t$0\n}, [$2])"
    ],
    "description": "react - useCallback"
  },
  "tsx-useState": {
    "prefix": [
      "usestat"
    ],
    "body": [
      "const [${1}, set${2}] = useState<${3:type}>(${4:init value})$0"
    ],
    "description": ""
  },
  "tsx-onSubmit": {
    "prefix": [
      "onsubm"
    ],
    "body": [
      "const onSubmit = useCallback(",
      "\t(e: FormEvent<HTMLFormElement>) => {",
      "\t\te.preventDefault()",
      "\t\t$0",
      "\t},",
      "\t[$1],",
      ")"
    ],
    "description": "onSubmit for <form>"
  },
  "new-promise": {
    "prefix": [
      "newp",
      "pro"
    ],
    "body": [
      "new Promise<${1:type}>((resolve, reject) => {",
      "\t$0",
      "})"
    ],
    "description": "new Promise<type>()"
  }
}
